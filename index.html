<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<title>Mini Match-3 ‚Äî Candy Style</title>
<style>
  :root{
    --bg:#0b0f1c; --panel:#131a2e; --ink:#eaf2ff; --mut:#9fb0d9;
    --g1:#ff6ec4; --g2:#7873f5; --ok:#aef7c1; --warn:#ffd86a;
    --size: clamp(44px, 9.5vw, 68px); /* tile size (mobile friendly) */
    --gap: 8px; --radius: 14px;
    --pulse: drop-shadow(0 0 8px rgba(255,255,255,.25));
  }
  *{box-sizing:border-box}
  html,body{height:100%}
  body{
    margin:0; background:
      radial-gradient(1200px 800px at 20% -10%, #202a57 0%, #10152a 45%, #0b0f1c 100%);
    color:var(--ink); font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
    display:grid; place-items:center; padding:20px;
  }
  .wrap{ width:min(92vw, 860px); }
  header{
    display:flex; align-items:center; justify-content:space-between; gap:12px; margin-bottom:14px;
  }
  .title{
    font-weight:800; letter-spacing:.3px;
    background:linear-gradient(90deg,var(--g1),var(--g2)); -webkit-background-clip:text; color:transparent;
    font-size:clamp(20px, 4.6vw, 28px);
  }
  .stats{ display:flex; gap:10px; flex-wrap:wrap; align-items:center; }
  .chip{
    background:linear-gradient(180deg, #1c2542, #131a2e);
    border:1px solid #263054; padding:8px 12px; border-radius:999px; font-weight:700;
    box-shadow: inset 0 1px 0 rgba(255,255,255,.06);
    white-space:nowrap; font-size:14px;
  }
  .btn{
    background:linear-gradient(180deg, #2a3560, #1a2447);
    border:1px solid #3a4683; padding:10px 14px; border-radius:12px; color:var(--ink);
    font-weight:800; letter-spacing:.2px; cursor:pointer; user-select:none;
    transition: transform .06s ease;
  }
  .btn:active{ transform: scale(.98); }
  .board{
    background: radial-gradient(800px 500px at 60% -40%, #1b2143, #10162f);
    border:1px solid #2c3360; border-radius:20px; padding:14px; box-shadow:
      inset 0 0 0 1px rgba(255,255,255,.04), 0 10px 40px rgba(0,0,0,.35);
  }
  .grid{
    display:grid; grid-template-columns: repeat(var(--cols), var(--size));
    gap: var(--gap);
    touch-action:none; /* allow swipe detection */
  }
  .tile{
    width:var(--size); height:var(--size); border-radius:var(--radius);
    display:grid; place-items:center; font-weight:900; font-size:22px;
    box-shadow: 0 4px 12px rgba(0,0,0,.25); filter: var(--pulse);
    position:relative; transition: transform .18s ease;
    user-select:none;
  }
  .tile:active{ transform: scale(.97); }
  /* Candy styles (colors + gloss) */
  .t0{ background: conic-gradient(from 180deg at 70% 20%, #ff88d7, #ff6ec4 40%, #d546a1 80%, #ff88d7);
       border:2px solid #ffb5e5; }
  .t1{ background: conic-gradient(from 160deg at 70% 20%, #8aa0ff, #6f7eff 40%, #4552d6 80%, #8aa0ff);
       border:2px solid #b9c2ff; }
  .t2{ background: conic-gradient(from 170deg at 70% 20%, #6af0ff, #41ddff 40%, #12a6c8 80%, #6af0ff);
       border:2px solid #a2f1ff; }
  .t3{ background: conic-gradient(from 170deg at 70% 20%, #ffd86a, #ffc83a 40%, #d49b07 80%, #ffd86a);
       border:2px solid #ffe79f; }
  .t4{ background: conic-gradient(from 165deg at 70% 20%, #aef7c1, #6be89a 40%, #2fb969 80%, #aef7c1);
       border:2px solid #c7fbd5; }

  .selected{ outline:3px solid #fff7; z-index:2; }
  .to-clear{ animation: pop .35s ease forwards; }
  @keyframes pop{ 30%{transform:scale(1.1)} 100%{transform:scale(0)} }

  .floating{
    position:fixed; left:50%; top:10px; transform:translateX(-50%);
    padding:10px 14px; border-radius:12px; background:#111733; border:1px solid #2b3566;
    font-weight:800; box-shadow:0 10px 30px rgba(0,0,0,.4); opacity:0; pointer-events:none;
    transition: opacity .15s ease, transform .15s ease;
  }
  .floating.show{ opacity:1; transform:translate(-50%, 0); }

  footer{ margin-top:12px; color:var(--mut); font-size:12px; text-align:center; }
</style>
</head>
<body>
  <div class="wrap">
    <header>
      <div class="title">üç¨ Mini Match-3</div>
      <div class="stats">
        <div class="chip">Score: <span id="score">0</span></div>
        <div class="chip">Moves: <span id="moves">20</span></div>
        <button id="shuffle" class="btn">Shuffle</button>
        <button id="restart" class="btn">Restart</button>
      </div>
    </header>

    <div class="board">
      <div id="grid" class="grid"></div>
    </div>

    <footer>Swap adjacent candies to make matches of 3+. Cascades score extra!</footer>
  </div>

  <!-- very small sounds (play on first interaction) -->
  <audio id="s-pop" preload="auto">
    <source src="data:audio/mp3;base64,//uQZAAAAAAAAAAAAAAAAAAAA..." type="audio/mp3">
  </audio>
  <audio id="s-swap" preload="auto">
    <source src="data:audio/mp3;base64,//uQZAAAAAAAAAAAAAAAAAAAA..." type="audio/mp3">
  </audio>

<script>
/* Mini Match-3 ‚Äî no dependencies */
(() => {
  const COLS = 8, ROWS = 8, TYPES = 5;
  const gridEl = document.getElementById('grid');
  const scoreEl = document.getElementById('score');
  const movesEl = document.getElementById('moves');
  const restartBtn = document.getElementById('restart');
  const shuffleBtn = document.getElementById('shuffle');
  const popSnd = document.getElementById('s-pop');
  const swapSnd = document.getElementById('s-swap');

  // CSS grid size
  gridEl.style.setProperty('--cols', COLS);

  let board = [];
  let score = 0;
  let moves = 20;
  let selected = null;      // {r,c}
  let busy = false;         // lock during animations

  // helpers
  const idx = (r,c) => r*COLS + c;
  const inBounds = (r,c) => r>=0 && r<ROWS && c>=0 && c<COLS;
  const randType = () => Math.floor(Math.random()*TYPES);

  // Sounds: play only after a user action (mobile autoplay rules)
  let audioEnabled = false;
  const safePlay = a => { if(audioEnabled) { a.currentTime=0; a.play().catch(()=>{}); } };

  function createBoard() {
    board = new Array(ROWS*COLS).fill(0);
    for (let r=0; r<ROWS; r++) {
      for (let c=0; c<COLS; c++) {
        // avoid immediate 3-in-a-row on creation
        let t;
        do {
          t = randType();
        } while( (c>=2 && t===board[idx(r,c-1)] && t===board[idx(r,c-2)]) ||
                 (r>=2 && t===board[idx(r-1,c)] && t===board[idx(r-2,c)]) );
        board[idx(r,c)] = t;
      }
    }
  }

  function render() {
    gridEl.innerHTML = '';
    for (let r=0; r<ROWS; r++) {
      for (let c=0; c<COLS; c++) {
        const t = board[idx(r,c)];
        const d = document.createElement('div');
        d.className = `tile t${t}`;
        d.dataset.r = r; d.dataset.c = c;
        d.role = 'button';
        d.ariaLabel = `Candy ${t+1} at row ${r+1}, col ${c+1}`;
        gridEl.appendChild(d);
      }
    }
  }

  function findMatches() {
    const toClear = new Set();
    // rows
    for (let r=0; r<ROWS; r++) {
      let run = 1;
      for (let c=1; c<=COLS; c++) {
        if (c<COLS && board[idx(r,c)] === board[idx(r,c-1)]) {
          run++;
        } else {
          if (run>=3) {
            for (let k=0; k<run; k++) toClear.add(idx(r,c-1-k));
          }
          run = 1;
        }
      }
    }
    // cols
    for (let c=0; c<COLS; c++) {
      let run = 1;
      for (let r=1; r<=ROWS; r++) {
        if (r<ROWS && board[idx(r,c)] === board[idx(r-1,c)]) {
          run++;
        } else {
          if (run>=3) {
            for (let k=0; k<run; k++) toClear.add(idx(r-1-k,c));
          }
          run = 1;
        }
      }
    }
    return [...toClear];
  }

  async function clearMatches(cells, cascadeStep=1) {
    if (!cells.length) return false;
    // animate removal
    cells.forEach(i => gridEl.children[i].classList.add('to-clear'));
    await wait(350);
    safePlay(popSnd);

    // score (simple: 10 per candy * cascade bonus)
    score += cells.length * 10 * cascadeStep;
    scoreEl.textContent = score;

    // remove (mark as -1)
    cells.forEach(i => board[i] = -1);

    // gravity
    for (let c=0; c<COLS; c++) {
      let write = ROWS-1;
      for (let r=ROWS-1; r>=0; r--) {
        const i = idx(r,c);
        if (board[i] !== -1) {
          board[idx(write,c)] = board[i];
          write--;
        }
      }
      for (let r=write; r>=0; r--) board[idx(r,c)] = -1;
    }

    // refill
    for (let r=0; r<ROWS; r++) {
      for (let c=0; c<COLS; c++) {
        if (board[idx(r,c)] === -1) board[idx(r,c)] = randType();
      }
    }

    render(); // re-render new pieces

    // check cascades
    const next = findMatches();
    if (next.length) {
      await clearMatches(next, cascadeStep+1);
    }
    return true;
  }

  function areAdj(a,b){
    const dr = Math.abs(a.r-b.r), dc = Math.abs(a.c-b.c);
    return (dr+dc===1);
  }

  async function trySwap(a,b) {
    if (!areAdj(a,b)) return;
    busy = true;
    swapBoard(a,b);
    // tiny swap animation hint
    safePlay(swapSnd);
    const ok = hasAnyMatchAt([a,b]);
    if (!ok) {
      // swap back (illegal)
      await wait(120);
      swapBoard(a,b);
      busy = false;
      return;
    }
    // a move was made
    moves--; movesEl.textContent = moves;
    // resolve matches/cascades
    const cells = findMatches();
    await clearMatches(cells);
    busy = false;

    if (moves<=0) toast("Out of moves! Press Restart.");
  }

  function swapBoard(a,b){
    const i1=idx(a.r,a.c), i2=idx(b.r,b.c);
    const tmp=board[i1]; board[i1]=board[i2]; board[i2]=tmp;
    // update only two DOM tiles quickly
    const t1 = gridEl.children[i1], t2 = gridEl.children[i2];
    if (t1 && t2) {
      const cl1 = t1.className, cl2 = t2.className;
      t1.className = 'tile t'+board[i1];
      t2.className = 'tile t'+board[i2];
    }
  }

  function hasAnyMatchAt(pairs){
    // quick check around swapped cells
    for (const p of pairs) {
      const {r,c} = p;
      const t = board[idx(r,c)];
      // row scan around c
      let run=1;
      for (let x=c-1; x>=0 && board[idx(r,x)]===t; x--) run++;
      for (let x=c+1; x<COLS && board[idx(r,x)]===t; x++) run++;
      if (run>=3) return true;
      // col scan
      run=1;
      for (let y=r-1; y>=0 && board[idx(y,c)]===t; y--) run++;
      for (let y=r+1; y<ROWS && board[idx(y,c)]===t; y++) run++;
      if (run>=3) return true;
    }
    return false;
  }

  function toast(msg){
    let el = document.querySelector('.floating');
    if (!el){
      el = document.createElement('div');
      el.className = 'floating';
      document.body.appendChild(el);
    }
    el.textContent = msg;
    el.classList.add('show');
    setTimeout(()=>el.classList.remove('show'), 1600);
  }

  function wait(ms){ return new Promise(res=>setTimeout(res,ms)); }

  // Input handling (click & touch swipe)
  function onSelect(r,c){
    if (busy || moves<=0) return;
    audioEnabled = true; // first interaction enables audio
    const current = {r,c};
    if (!selected){
      selected = current;
      tileAt(r,c)?.classList.add('selected');
    } else {
      const prev = selected;
      tileAt(prev.r, prev.c)?.classList.remove('selected');
      selected = null;
      trySwap(prev, current);
    }
  }

  function tileAt(r,c){ return gridEl.children[idx(r,c)]; }

  // Touch swipe (select then auto swap towards swipe direction)
  let touchStart = null;
  function onTouchStart(e){
    const t = e.target.closest('.tile'); if(!t) return;
    const r = +t.dataset.r, c = +t.dataset.c;
    touchStart = {r,c, x:e.touches[0].clientX, y:e.touches[0].clientY};
    e.preventDefault();
  }
  function onTouchEnd(e){
    if (!touchStart) return;
    const endX = e.changedTouches[0].clientX;
    const endY = e.changedTouches[0].clientY;
    const dx = endX - touchStart.x;
    const dy = endY - touchStart.y;
    const absX = Math.abs(dx), absY = Math.abs(dy);
    const {r,c} = touchStart;
    touchStart = null;
    if (absX<10 && absY<10){ onSelect(r,c); return; }
    let rr=r, cc=c;
    if (absX>absY) cc = c + (dx>0? 1: -1); else rr = r + (dy>0? 1: -1);
    if (!inBounds(rr,cc)) return;
    if (busy || moves<=0) return;
    audioEnabled = true;
    trySwap({r,c},{r:rr,c:cc});
  }

  function onClick(e){
    const t = e.target.closest('.tile'); if(!t) return;
    const r = +t.dataset.r, c = +t.dataset.c;
    onSelect(r,c);
  }

  function restart(){
    score = 0; moves = 20;
    scoreEl.textContent = score; movesEl.textContent = moves;
    selected = null; busy = false;
    createBoard(); render();
  }

  function shuffle(){
    if (busy) return;
    // simple shuffle of board contents (doesn't guarantee solvable)
    board = board.sort(()=>Math.random()-0.5);
    render();
    toast('Shuffled!');
  }

  // Init
  createBoard(); render();
  gridEl.addEventListener('click', onClick);
  gridEl.addEventListener('touchstart', onTouchStart, {passive:false});
  gridEl.addEventListener('touchend', onTouchEnd);

  restartBtn.addEventListener('click', restart);
  shuffleBtn.addEventListener('click', shuffle);
})();
</script>
</body>
</html>
